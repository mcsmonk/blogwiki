---
layout  : wiki
title   : iamroot16 History
summary :
date    : 2019-08-18 20:00:00 +0900
updated : 2020-12-12 20:00:00 +0900
tag     : study linux record
resource: 8F/0E134B-8673-40F3-8DB7-1A615E84614E
toc     : true
comment : true
public  : true
parent  : [[diary]]
latex   : false
---
* TOC
{:toc}

Iamroot 16차 Linux-Kernel-v5.1-arm64 스터디 기록용

# Resources

1. __Iamroot16 주요 사이트__
    0. 16차 통합 커널소스 깃허브 저장소 \[[link](https://github.com/iamroot16/linux)\]
    1. 16차 통합 구글 드라이브 \[[link](https://drive.google.com/drive/folders/1k1f0Q87LehqTN7P--gZ777t-srVI-urm)\]  
    2. 16차 통합 슬랙 \[[link](https://app.slack.com/client/TQNJN657T/CQNJN69AM)\]
    3. 16차 B조 커널소스 깃허브 저장소 \[[link](https://github.com/iamroot16b/linux)\]

2. __참고 사이트__
    0. Linux kernel git repository [link](https://github.com/torvalds/linux)
    1. 문C블로그 [link](http://jake.dothome.co.kr/)
    2. Iamroot [link](http://www.iamroot.org/xe/)
    3. 커널연구회 [link](https://kernel.bz/kernel)
    4. Linux Kernel(4.19) Hacks 블로그 [link](http://rousalome.egloos.com/)
    5. LWN.net [link](https://lwn.net/Kernel/Index/)
    6. GNU manual [link](http://www.gnu.org/manual/), korea [link](http://korea.gnu.org/manual/)

# Records

<!--
20 - 주차 - (+)명 - 
201128 - 7주차 - (?+2?)명 - 강남 모임플러스 + 온라인 참석
21 - 주차 - (+)명 - 
-->

201212 - 73주차 - (?+?)명 - 강남 모임플러스 + 온라인 참석

201205 - 72주차 - (?+3?)명 - 강남 모임플러스 + 온라인 참석

201128 - 71주차 - (?+2?)명 - 강남 모임플러스 + 온라인 참석

201121 - 70주차 - (9+2)명 - 강남 모임플러스 + 온라인 참석

201114 - 69주차 - (8+3)명 - 강남 이지스터디

201107 - 68주차 - (10+1)명 - 강남 모임플러스 + 온라인 참석

201031 - 67주차 - (11+1)명 - 강남 모임플러스 + 온라인 참석

~~201024 - 66주차 - (?+?)명 - 강남 모임플러스 + 온라인 참석~~ - __개인 사정 불참__

201017 - 65주차 - (13?+2)명 - 강남 모임플러스 + 온라인 참석

201010 - 64주차 - (?+?)명 - 강남 모임플러스 + 온라인 참석 - 7시부터 참석

200926 - 63주차 - (4+10)명 - 강남 이지스터디 + 온라인 참석

200919 - 62주차 - 9명 - 온라인

200912 - 61주차 - 11명 - 온라인

200905 - 60주차 - 11명 - 온라인

200829 - 59주차 - 9명 - 온라인 - 코로나로 인한 전체 화상 원격 회의 첫 시도

200822 - 코로나로 인한 취소

200815 - 여름 휴가

200808 - 58주차 - (11+1)명 - 강남 이지스터디 + 온라인

200801 - 57주차 - 15명 - 강남 이지스터디

200725 - 56주차 - 15명 - 강남 힐스터디

200718 - 55주차 - ?명 - 강남 이지스터디 - 초반 1시간 30분만 참여

200711 - 54주차 - 11명 - 강남 이지스터디

200704 - 53주차 - 14명 - 강남 이지스터디 - 문영일님 참석

200627 - 52주차 - 14명 - 강남 이지스터디 - 문영일님 참석

200620 - 51주차 - (11+1)명 - 강남 이지스터디 + 온라인

200613 - 50주차 - 13명 - 강남 이지스터디

200606 - 49주차 - (11+2)명 - 강남 이지스터디 + 온라인

200530 - 48주차 - (13+1)명 - 강남 이지스터디 + 온라인

200523 - 47주차 - 13명 - 강남 이지스터디

200516 - 46주차 - (12+1)명 - 강남 이지스터디 + 온라인

~~200509 - 45주차 - (+)명 - 강남 이지스터디~~ - __친구 결혼식__

200425 - 44주차 - (?+1?)명 - 강남 공간이즈 - 온라인 참석

200418 - 43주차 - (11+3)명 - 강남 이지스터디 - 온라인 참석

200411 - 42주차 - (10+3)명 - 강남 SG스터디 본관

200404 - 41주차 - (7+5)명 - 강남 힐스터디

200328 - 40주차 - 8명 - 한양대학교 퓨전테크센터 403호 세미나실

200321 - 39주차 - 8명 - 한양대학교 퓨전테크센터 403호 세미나실

200314 - 38주차 - 명 - 한양대학교 퓨전테크센터 403호 세미나실

200307 - 37주차 - 10명 - 한양대학교 퓨전테크센터 403호 세미나실

~~200229 - 36주차 - ?명 - 한양대학교 퓨전테크센터 403호 세미나실 - 온라인 참석~~ - __코로나로 인한 원격회의 시도 및 실패__

200222 - 35주차 - 14명 - 논현 인스페이스

200215 - 34주차 - 14명 - 세종대학교 대양AI센터 B20

200208 - 33주차 - 14명 - 한양대학교 퓨전테크센터 403호 세미나실

~~200201 - 32주차 - ?명 - 세종대학교 대양AI센터 B103~~ - __휴가__

200118 - 31주차 - 명 - 한양대학교 퓨전테크센터 403호 세미나실

200111 - 30주차 - 15명 - 세종대학교 대양AI센터 B103

200104 - 29주차 - 16명 - 세종대학교 대양AI센터 B103

191221 - 28주차 - ?명 - 세종대학교 대양AI센터 B102 - __주말 여행__

191214 - 27주차 - 16명 - 세종대학교 대양AI센터 B102

191207 - 26주차 - 11명 - 세종대학교 대양AI센터 B102

191130 - 25주차 - 12명 - 세종대학교 충무관 - 친척 형 결혼식 후 7시부터 참석

191123 - 24주차 - 18명 - 세종대학교 대양AI센터 - 통합 시작 !

191116 - 20주차(23주차) - 2명 - 고려대학교 미래융합기술관

191109 - 19주차 - 명 - 세종대학교 광개토관 428호, 통합 스터디 2차 시도

191102 - 18주차 - 18명 - 세종대학교 대양AI센터, 통합 스터디 시도

191025 - 17주차 - 2명 - 고려대학교 미래융합기술관, 통합논의 강남 힐스터디

191019 - 16주차 - 2명 - 고려대학교 미래융합기술관

191012 - 15주차 - 2명 - 고려대학교 미래융합기술관

191005 - 14주차 - 3명 - 강남 스터디블룸

190921 - 13주차 - 2명 - 강남 슈퍼스타트

~~190914 - 13주차 - ?명 - ?~~ - __추석__ ~~핑계가 너무 많다~~

~~190907 - 13주차 - ?명 - ?~~ - __태풍 링링__

~~190824 - 12주차 - ?명 - ?~~ - __CHES 2019 참석__

190817 - 11주차 - 6명 - 강남 힐스터디

190810 - 25명 - Iamroot 16기 연합스터디

190803 - 10주차 - 6명 - 강남 힐스터디

190720 - 9주차 - 8명 - 강남 슈퍼스타트

> arch/arm64/kernel/head.S 분석 완료  
> init/main.c : start_kernel 분석 시작  

190713 - 8주차 - 7명 - 독산 모카플레이스

~~190706 - 7주차 - ?명 - 강남 SG 스터디룸~~ - __휴가 제주도__

190629 - 6주차 - 15명 - 강남 공간이즈

~~190622 - 5주차 - 15명 - 이수역 코지모임공간 교대점~~ - __CISC-S 2019 발표__

> arch/arm64/kernel/head.S 분석 시작

190615 - 4주차 - ?명 - 고려대학교 로봇융합관 301호

190608 - 3주차 - ?명 - 고려대학교 로봇융합관 301호

190601 - 2주차 - ?명 - 광운대학교 비마관 504호

190525 - 1주차 - ?명 - 고려대학교 우정정보관 202호

190518 - 0주차 - 오리엔테이션


# 스터디 진행 내용

<!--
## 주차
> 요약  
>- start_kernel (init/main.c)  
>  -  ()  
>    -   
>  -  ()  
>    -   

1. 정리
    - 

참고
0. Kernel patch commit message
    - 
1. Kernel Doc
    - 
2. 문C블로그
    - 
3. GCC Doc
    - 
4. ARM Doc
    - 
5. etc
    - 
-->

## 주차
> 요약  
>- alloc_pages (include/linux/gfp.h)  
>  - alloc_pages_current (mm/mempolicy.c)  
>    - __alloc_pages_nodemask (mm/page_alloc.c)  
>      - current_gfp_context (include/linux/sched/mm.h)  
>      - __alloc_pages_slowpath  
>        - gfp_to_alloc_flags  
>        - first_zones_zonelist  
>        - wake_all_kswapds  
>        - get_page_from_freelist  
>        - gfp_pfmemalloc_allowed  
>          - __gfp_pfmemalloc_flags  
>        - __alloc_pages_direct_compact  
>          - memalloc_noreclaim_save  
>          - try_to_compact_pages  
>          - compact_zone_order  
>            - compact_zone  
>              - compaction_suitable  
>                - __compaction_suitable  
>                  - is_via_compact_memory  
>                  - wmark_pages  
>                  - zone_watermark_ok  
>                  - compact_gap  

참고
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/accounting/psi.txt : PSI - Pressure Stall Information
2. 문C블로그
    - http://jake.dothome.co.kr/gfp-flag/ : GFP 플래그
    - http://jake.dothome.co.kr/zonned-allocator-alloc-pages-fastpath/ : Zoned Allocator -1- (물리 페이지 할당-Fastpath)
    - http://jake.dothome.co.kr/zonned-allocator-watermark/ : Zoned Allocator -6- (Watermark)
5. etc
    - https://lwn.net/Articles/224829/ : Short topics in memory management
    - https://www.kernel.org/doc/gorman/html/understand/understand009.html : Chapter 6  Physical Page Allocation
    - https://tooson.tistory.com/2 : Memory Allocation Mechanism

## 72주차
> 요약  
>- alloc_pages (include/linux/gfp.h)  
>  - alloc_pages_current (mm/mempolicy.c)  
>    - __alloc_pages_nodemask (mm/page_alloc.c)  
>      - get_page_from_freelist  
>        - rmqueue  
>          - __rmqueue  
>          - mod_zone_freepage_state (include/linux/vmstat.h)  
>            - __mod_zone_page_state (mm/vmstat.c)  
>          - zone_statistics  
>        - prep_new_page  
>          - post_alloc_hook  
>          - prep_compound_page  
>        - reserve_highatomic_pageblock  
>          - get_pageblock_migratetype (include/linux/mmzone.h)  

참고
2. 문C블로그
    - http://jake.dothome.co.kr/cache4/ : Cache – Coherent
    - http://jake.dothome.co.kr/zonned-allocator-watermark/ : Zoned Allocator -6- (Watermark)
    - http://jake.dothome.co.kr/compound/ : Compound 페이지
5. etc
    - (책) 2011-A Primer on Memory Consistency and Cache Coherence
    - https://sonseungha.tistory.com/488 : NUMA BALANCING
    - https://jihooyim1.gitbooks.io/linuxbasic/content/contents/06.html : NUMA, 메모리 관리의 새로운 세계
    - https://blog.naver.com/xowns4817/221182043348 : TLB(Translation Lookaside Buffer)
    - https://www.spinics.net/lists/newbies/msg41159.html : Re: what is "compound_page()" all about?

## 71주차
> 요약  
>- alloc_pages (include/linux/gfp.h)  
>  - alloc_pages_current (mm/mempolicy.c)  
>    - __alloc_pages_nodemask (mm/page_alloc.c)  
>      - get_page_from_freelist  
>        - rmqueue  
>          - __rmqueue  
>          - mod_zone_freepage_state (include/linux/vmstat.h)  
>            - __mod_zone_page_state  

참고
0. Kernel patch commit message
    - https://github.com/iamroot16/linux/commit/4eb7dce62007113f1a2778213980fd6d8034ef5e : mm/page_alloc: factor out fallback freepage checking
    - https://lore.kernel.org/linux-mm/20170307131545.28577-5-vbabka@suse.cz/ : mm, page_alloc: count movable pages when stealing from pageblock
    - https://lkml.org/lkml/2017/2/10/582 : mm, page_alloc: split smallest stolen page in fallback
2. 문C블로그
    - http://jake.dothome.co.kr/zonned-allocator-alloc-pages-fastpath/ : Zoned Allocator -1- (물리 페이지 할당-Fastpath)
5. etc
    - https://tooson.tistory.com/2 : Memory Allocation Mechanism
    - https://www.youtube.com/watch?v=mzT4QnCpef8 : LPC2018 - The hard work behind large physical allocations in the kernel
    - https://lwn.net/Articles/348886/ : HWPOISON

## 70주차
> 요약  
>- alloc_pages (include/linux/gfp.h)  
>  - alloc_pages_current (mm/mempolicy.c)  
>    - __alloc_pages_nodemask (mm/page_alloc.c)  
>      - get_page_from_freelist  
>        - zone_watermark_fast  
>          - __zone_watermark_ok  
>        - zone_allows_reclaim 
>        - node_reclaim (mm/vmscan.c) 
>        - rmqueue  
>          - rmqueue_pcplist  
>            - __rmqueue_pcplist  
>              - rmqueue_bulk  
>          - __rmqueue_smallest  
>          - __rmqueue  
>            - __rmqueue_fallback  
>              - find_suitable_fallback  
>                - can_steal_fallback  
>              - steal_suitable_fallback  
>                - move_freepages_block  
>                  - move_freepages  

참고
2. 문C블로그
    - http://jake.dothome.co.kr/zonned-allocator-watermark/ : Zoned Allocator -6- (Watermark)
    - http://jake.dothome.co.kr/zonned-allocator-alloc-pages-fastpath/ : Zoned Allocator -1- (물리 페이지 할당-Fastpath)
    - http://jake.dothome.co.kr/build_all_zonelists/ : build_all_zonelists()
    - http://jake.dothome.co.kr/buddy-alloc/ : Zonned Allocator -3- (Buddy 페이지 할당)
    - http://jake.dothome.co.kr/sparsemem/ : Sparse Memory
5. etc
    - https://linuxplumbersconf.org/event/2/contributions/65/attachments/15/171/slides-expanded.pdf : The hard work behind large physical memory allocations in the kernel

## 69주차
> 요약  
>- alloc_pages (include/linux/gfp.h)  
>  - alloc_pages_current (mm/mempolicy.c)  
>    - __alloc_pages_nodemask (mm/page_alloc.c)
>      - prepare_alloc_pages  
>        - gfp_zone  
>      - finalise_ac  
>      - alloc_flags_nofragment  
>      - get_page_from_freelist  
>        - node_dirty_ok  
>        - wmark_pages  
>        - zone_watermark_fast  
>          - __zone_watermark_ok  

참고
2. 문C블로그
    - http://jake.dothome.co.kr/debug-mem-5/ : 디버그 메모리 -5- (Fault Injection)
    - http://jake.dothome.co.kr/build_all_zonelists/ : build_all_zonelists()
    - http://jake.dothome.co.kr/zonned-allocator-alloc-pages-fastpath/ : Zoned Allocator -1- (물리 페이지 할당-Fastpath)
5. etc
    - http://egloos.zum.com/studyfoss/v/5342153 : \[Linux\] lockdep: 런타임 락 의존성 검사

## 68주차
> 요약  
>- 2017-Mastering Linux Kernel Development  
>  - ch4.Memory Management And Allocator (pp.124-139)
>  
>- alloc_pages (include/linux/gfp.h)  
>  - alloc_pages_current (mm/mempolicy.c)  
>    - __alloc_pages_nodemask (mm/page_alloc.c) <-- 분석하다가 중단  
>      - get_page_from_freelist  
>        - rmqueue  
>          - __rmqueue_smallest <-- 분석 완료  
>            - rmv_page_order
>              - __ClearPageBuddy (include/linux/page-flags.h:716)  
>            - expand  
>              - set_page_guard  
>              - set_page_order  
>                - __SetPageBuddy (include/linux/page-flags.h:716)  

1. 정리
    - Memory management 정리
        - page descriptor
            - page frame
            - page structure
            - flag
            - mapping
        - Zones and nodes
            - Memory zones
                - DMA, DMA32, HIGHMEM, NORMAL, MOVABLE, DEVICE
            - Memory nodes
            - node descriptor structure
            - zone descriptor structure
        - memory allocator
            - page frame allocator
            - buddy system
            - GFP mask
            - slab allocator
                - kmalloc cache
                - object cache
                - cache management
                - slob -> slab -> slub

참고
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/vm/numa_memory_policy.txt
2. 문C블로그
    - http://jake.dothome.co.kr/gfp-flag/ : GFP 플래그
    - http://jake.dothome.co.kr/2019/07/ : NUMA -3- (Memory policy)
5. etc
    - https://events.static.linuxfound.org/sites/events/files/slides/slaballocators.pdf : Slab allocators in the Linux Kernel: SLAB, SLOB, SLUB
    - http://studyfoss.egloos.com/5332580 : 동적 메모리 할당자 : slab, slub, slob
    - https://12bme.tistory.com/537 : NUMA 메모리 관리 아키텍처

## 67주차
> 요약  
>- start_kernel (init/main.c)  
>  - page_alloc_init (mm/page_alloc.c)  
>    - page_alloc_cpu_dead  
>      - lru_add_drain_cpu (mm/swap.c)  
>        - __pagevec_lru_add  
>          - __pagevec_lru_add_fn  
>          - pagevec_lru_move_fn - 스탑  
>- 2017-Mastering Linux Kernel Development  
>  - ch4.Memory Management And Allocator (pp.95-123)

1. 정리
    - 원혁님 첫 커밋
      - [https://lore.kernel.org/linux-mm/20201030201946.GA1061822@google.com/T/#t](https://lore.kernel.org/linux-mm/20201030201946.GA1061822@google.com/T/#t)
    - Memory management 정리

참고
2. 문C블로그
    - http://jake.dothome.co.kr/kboard/?mod=document&uid=26 : Q&A - Zone의 필요성에 대하여
    - http://jake.dothome.co.kr/zonned-allocator-watermark/ : Zoned Allocator -6- (Watermark)
    - http://jake.dothome.co.kr/per-cpu-page-frame-cache/ : Zoned Allocator -5- (Per-CPU Page Frame Cache)
4. ARM Doc
    - https://pages.arm.com/rs/312-SAX-488/images/Arm_Cortex_M_Book_2019_pdf_Oct19.pdf : System-on-Chip Design with Arm® Cortex® -M Processors
5. etc
    - 2017-Mastering Linux Kernel Development-ch4.Memory Management And Allocator

## 65주차
> 요약  
>- start_kernel (init/main.c)  
>  - smp_prepare_boot_cpu (arch/arm64/kernel/smp.c)  
>    - init_gic_priority_masking (arch/arm64/kernel/smp.c)  
>  - build_all_zonelists (mm/page_alloc.c)  
>    - build_all_zonelists_init  
>      - __build_all_zonelists  
>        - build_zonelists  
>          - find_next_best_node  
>          - build_zonelists_in_node_order  
>            - build_zonerefs_node  
>              - managed_zone (include/linux/mmzone.h)  
>                - zone_managed_pages  
>              - zoneref_set_zone  
>              - check_highest_zone (include/linux/mempolicy.h)  
>          - build_thisnode_zonelists  
>        - cpu_to_node  
>        - local_memory_node  
>          - node_zonelist (include/linux/gfp.h)  
>          - gfp_zone  
>          - first_zones_zonelist  
>            - next_zones_zonelist  
>              - __next_zones_zonelist  

1. 정리
    - gfp(get free pages)

참고
0. Kernel patch commit message
    - https://patchwork.kernel.org/project/linux-arm-kernel/patch/1542023835-21446-16-git-send-email-julien.thierry@arm.com/ : arm64: Switch to PMR masking when starting CPUs
    - https://gitlab.apertis.org/third-party/linux/commit/cff7d378d3fdbb53db9b6e2578b14855f401cd41 : cpu/hotplug: Convert to a state machine for the control processor
    - https://lore.kernel.org/patchwork/patch/974406/ : cpu/hotplug: Boot HT siblings at least once
    - https://github.com/torvalds/linux/commit/c9bff3eebc09be23fbc868f5e6731666d23cbea3#diff-d1793bdc2ce9e21814061bb882d0c3ac : mm, page_alloc: rip out ZONELIST_ORDER_ZONE
1. Kernel Doc
    - https://www.kernel.org/doc/html/latest/core-api/cpu_hotplug.html
2. 문C블로그
    - http://jake.dothome.co.kr/arm64-handler/
    - http://jake.dothome.co.kr/build_all_zonelists/
    - http://jake.dothome.co.kr/numa-1/
    - http://jake.dothome.co.kr/zone-api/
    - http://jake.dothome.co.kr/boot_cpu_init/
5. etc
    - https://blog.naver.com/seuis398/70140453358 : 리눅스 CPU 동적으로 ON/OFF 시키기 (CPU Hotplug)

## 64주차
> 요약  
>- start_kernel (init/main.c)  
>  - smp_prepare_boot_cpu (arch/arm64/kernel/smp.c)  
>    - apply_boot_alternatives (arch/arm64/kernel/alternative.c)  
>    - system_uses_irq_prio_masking (arch/arm64/include/asm/cpufeature.h)  
>    - init_gic_priority_masking (arch/arm64/kernel/smp.c)  

1. 정리
    - 정리 필요 ...

참고
2. 문C블로그
    - http://jake.dothome.co.kr/ic/
5. etc
    - https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/caches-and-self-modifying-code : Caches and Self-Modifying Code

## 63주차
> 요약  
>- start_kernel (init/main.c)  
>  - smp_prepare_boot_cpu (arch/arm64/kernel/smp.c)  
>    - cpuinfo_store_boot_cpu (arch/arm64/kernel/cpuinfo.c)  
>      - init_cpu_features (arch/arm64/kernel/cpufeature.c)  
>        - init_cpu_ftr_reg  
>          - get_arm64_ftr_reg  
>          - arm64_ftr_mask (arch/arm64/include/asm/cpufeature.h)  
>          - arm64_ftr_value (arch/arm64/include/asm/cpufeature.h)  
>          - arm64_ftr_set_value  
>        - sve_init_vq_map  
>        - init_cpu_hwcaps_indirect_list  
>          - init_cpu_hwcaps_indirect_list_from_array  
>        - setup_boot_cpu_capabilities  
>          - update_cpu_capabilities  
>          - enable_cpu_capabilities  
>            - cpu_enable_non_boot_scope_capabilities  
>            - stop_machine (kernel/stop_machine.c)  
>              - stop_machine_cpuslocked  
>                - set_state  
>                - stop_cpus  
>                - multi_cpu_stop  
>    - apply_boot_alternatives (arch/arm64/kernel/alternative.c)  
>      - __apply_alternatives  
>        - patch_alternative  
>          - get_alt_insn  

참고
0. Kernel patch commit message
    - https://github.com/torvalds/linux/commit/3c739b57108436211c7f798ba3de0bb0cd8ef469 : arm64: Keep track of CPU feature registers
    - https://github.com/torvalds/linux/commit/fe4fbdbcddeaab58a4f9b5297f28b8a4babf6f1f : arm64: cpufeature: Track user visible fields
    - https://patchwork.kernel.org/patch/10706875/: arm64: capabilities: Speed up capability lookup
1. Kernel Doc
    - https://www.kernel.org/doc/html/latest/arm64/silicon-errata.html
2. 문C블로그
    - http://jake.dothome.co.kr/cpucaps64/
    - http://jake.dothome.co.kr/alternative/
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html
4. ARM Doc
    - https://developer.arm.com/architectures/instruction-sets/simd-isas
    - https://developer.arm.com/documentation/dai0548/latest : SVE Programming Examples
    - https://community.arm.com/developer/tools-software/oss-platforms/b/android-blog/posts/runtime-detection-of-cpu-features-on-an-armv8-a-cpu : Runtime detection of CPU features on an ARMv8-A CPU
5. etc
    - https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)

## 62주차
> 요약  
>- static-keys  
>  - 관련 코드들  
>  
>- start_kernel (init/main.c)  
>  - smp_prepare_boot_cpu (arch/arm64/kernel/smp.c)  
>    - cpuinfo_store_boot_cpu (arch/arm64/kernel/cpuinfo.c)  
>      - __cpuinfo_store_cpu  
>        - id_aa64pfr0_32bit_el0 (arch/arm64/kernel/cpufeature.h)  
>        - id_aa64pfr0_sve (arch/arm64/kernel/cpufeature.h)  
>        - cpuinfo_detect_icache_policy  
>      - init_cpu_features (arch/arm64/kernel/cpufeature.c)  
>        - sort_ftr_regs  
>        - init_cpu_ftr_reg  
>          - get_arm64_ftr_reg  

참고
2. 문C블로그
    - http://jake.dothome.co.kr/smp_prepare_boot_cpu/
    - http://jake.dothome.co.kr/cpucaps64/
4. ARM Doc
    - https://developer.arm.com/documentation/aeg0014/g/glossary -> RES0

## 61주차
> 요약  
>- start_kernel (init/main.c)  
>  - smp_prepare_boot_cpu (arch/arm64/kernel/smp.c)  
>    - jump_label_init (kernel/jump_label.c)  
>      - jump_entry_code  
>      - init_section_contains (include/asm-generic/sections.h)  
>        - memory_contains  
>      - static_key_set_entries  
>  
>- static key 개념 및 동작 방법 이해

참고
0. Kernel patch commit message
    - https://lore.kernel.org/lkml/20120222085809.GA26397@elte.hu/
2. 문C블로그
    - http://jake.dothome.co.kr/inline-assembly/
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html

## 60주차
> 요약  
> 1. 진행사항
>  - start_kernel (init/main.c)  
>    - smp_prepare_boot_cpu (arch/arm64/kernel/smp.c)  
>      - set_my_cpu_offset (arch/arm64/include/asm/percpu.h)  
>      - jump_label_init (kernel/jump_label.c)  
>        - cpus_read_lock (일단 생략)  
>        - jump_label_lock  
>        - jump_label_sort_entries  
>          - sort (lib/sort.c)  
>        - jump_label_type  
>          - jump_entry_key (include/linux/jump_label.h)  
>          - static_key_enabled  
>            - static_key_count  
>          - jump_entry_is_branch  
>        - jump_entry_code  
>        - init_section_contains (include/asm-generic/sections.h)  
>          - memory_contains  

1. 정리
    - 정리 필요 !

참고
0. Kernel patch commit message
    - https://lore.kernel.org/patchwork/patch/680327/ : \[v2,1/4\] jump_label: remove bug.h, atomic.h dependencies for HAVE_JUMP_LABEL
    - https://lore.kernel.org/linux-arm-kernel/20180919065144.25010-3-ard.biesheuvel@linaro.org/ : \[PATCH v3 2/9\] kernel/jump_label: implement generic support for relative references
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/atomic_t.txt
    - https://www.kernel.org/doc/Documentation/core-api/atomic_ops.rst
    - https://www.kernel.org/doc/Documentation/percpu-rw-semaphore.txt
2. 문C블로그
    - http://jake.dothome.co.kr/smp_prepare_boot_cpu/
    - http://jake.dothome.co.kr/jump_label_init/
    - http://jake.dothome.co.kr/rcu/
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Pointer-Arith.html
5. etc
    - https://lwn.net/Articles/531148/ : Special sections in Linux binaries
    - http://tomoyo.osdn.jp/cgi-bin/lxr/source/kernel/jump_label.c
    - https://www.youtube.com/watch?v=a5kq0vbfmYQ : [TOT0Ro](https://tot0rokr.github.io/)님의 jump_label_init() 동작 설명 동영상

## 59주차
> 요약  
> 1. 진행사항
>    - setup_per_cpu_areas 개념 복습
>    - static-key 분석
>      - include/linux/jump_label.h
>      - arch/arm64/include/asm/jump_label.h

1. 정리
    - 원격 화상 회의를 통한 스터디 진행
      - 15-18 : meet을 이용
        - 화질 안 좋음
        - 마이크 노이즈 심함
        - 카톡 음성 채팅으로 대체
    - setup_per_cpu_areas 개념 복습
    - static-key 분석

참고
0. Kernel patch commit message
    - https://github.com/torvalds/linux/commit/11276d5306b8e5b438a36bbff855fe792d7eaa61
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/static-keys.txt
    - https://www.kernel.org/doc/Documentation/trace/tracepoints.txt
2. 문C블로그
    - http://jake.dothome.co.kr/per-cpu/
    - http://jake.dothome.co.kr/jump_label_init/
    - http://jake.dothome.co.kr/static-keys/
5. etc
    - https://wariua.github.io/facility/labels-and-static-key.html
    - https://gcc.gnu.org/legacy-ml/gcc-patches/2009-07/msg01556.html
    - https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/07/20/linux-static-key-internals

## 58주차
> 요약  
> 1. 진행사항
>  - start_kernel (init/main.c)  
>    - setup_per_cpu_areas (arch/arm64/mm/numa.c)  
>      - pcpu_embed_first_chunk (mm/percpu.c)  
>        - pcpu_setup_first_chunk  
>          - __pcpu_size_to_slot  
>          - pcpu_alloc_first_chunk  
>            - pcpu_block_update_hint_alloc  
>              - pcpu_block_refresh_hint  
>              - pcpu_chunk_refresh_hint  
>                - pcpu_next_md_free_region  
>                - pcpu_chunk_update  
>                - pcpu_cnt_pop_pages  
>          - pcpu_chunk_relocate  

참고
2. 문C블로그
    - http://jake.dothome.co.kr/per-cpu/
    - http://jake.dothome.co.kr/setup_per_cpu_areas/
    - http://jake.dothome.co.kr/bit-operations/
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html

## 57주차
> 요약  
> 1. 진행사항
>  - start_kernel (init/main.c)  
>    - setup_per_cpu_areas (arch/arm64/mm/numa.c)  
>      - pcpu_embed_first_chunk (mm/percpu.c)  
>        - pcpu_setup_first_chunk  
>          - __pcpu_size_to_slot  
>          - pcpu_alloc_first_chunk  
>            - pcpu_chunk_map_bits  
>            - pcpu_chunk_nr_blocks  
>            - pcpu_init_md_blocks  
>            - bitmap_fill  
>            - pcpu_cnt_pop_pages  
>            - pcpu_block_update_hint_alloc  
>              - pcpu_off_to_block_index  
>              - pcpu_off_to_block_off  
>              - pcpu_index_alloc_map  

1. 정리
    - bug ?
      - mm/percpu.c:1105
      ``` c
      alloc_size = sizeof(struct pcpu_chunk) +
                BITS_TO_LONGS(region_size >> PAGE_SHIFT);
      chunk = memblock_alloc(alloc_size, SMP_CACHE_BYTES);
      ```
      ``` c
      struct pcpu_chunk {
        ...
        unsigned long           populated[];    /* populated bitmap */
      };
      ```
      - BITS_TO_LONGS(region_size >> PAGE_SHIFT); -?-> BITS_TO_LONGS(region_size >> PAGE_SHIFT) * sizeof(unsigned long); 
      - Check whether chunk->populated is used directly : USE !!
      - 첫 커널 패치 제출 : [https://lkml.org/lkml/2020/8/2/94](https://lkml.org/lkml/2020/8/2/94)
        - 컨벤션 미준수 ... 다음엔 제대로 해보기 !
      
참고
0. Kernel patch commit message
    - https://github.com/iamroot16/linux/commit/ca460b3c96274d79f84b31a3fea23a6eed479917 : percpu: introduce bitmap metadata blocks
    - https://github.com/iamroot16/linux/commit/8ab16c43ea79098f4126432c6b199a5d6ba24b6d : percpu: change the number of pages marked in the first_chunk pop bitmap
      - https://github.com/iamroot16/linux/blob/8ab16c43ea79098f4126432c6b199a5d6ba24b6d/mm/percpu.c
        ``` c
        pcpu_chunk_struct_size = sizeof(struct pcpu_chunk) +
		                        BITS_TO_LONGS(pcpu_unit_pages) * sizeof(unsigned long);
        ...
        chunk = memblock_virt_alloc(pcpu_chunk_struct_size, 0);
        ```
        ->
        ``` c
        chunk = memblock_virt_alloc(sizeof(struct pcpu_chunk) +
                BITS_TO_LONGS(region_size >> PAGE_SHIFT),
                0);
        ```
2. 문C블로그
    - http://jake.dothome.co.kr/setup_nr_cpu_ids/
    - http://jake.dothome.co.kr/per-cpu/
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc-4.5.0/gcc/Conditionals.html#Conditionals
5. etc
    - https://kjhg4321.gitbook.io/doodl/per-cpu : 양원혁님 per-cpu 정리
    - http://forum.falinux.com/zbxe/index.php?document_srl=533512&mid=Kernel_API : 커널 API - Bit 처리 매크로

## 56주차
> 요약  
> 1. 진행사항
>  - start_kernel (init/main.c)  
>    - setup_per_cpu_areas (arch/arm64/mm/numa.c)  
>      - pcpu_embed_first_chunk (mm/percpu.c)  
>        - pcpu_build_alloc_info  
>          - pcpu_alloc_alloc_info  
>        - pcpu_setup_first_chunk  

1. 정리
    - define 문에서 do { ... } while(0) 으로 정의하는 이유
      - empty statement일 경우 컴파일러 경고
      - Dangling else 문제 방지
    - 아래 내용 정리 필요
      - multiprocessor
      - multicore
      - SMP (Symmetric MultiProcessing)
        - Symmetric multiprocessors include two or more identical processors sharing a single main memory. The multiple processors may be separate chips or multiple cores on the same chip.
      - UMA (Uniform Memory Access)
      - NUMA (Non-Uniform Memory Access)
      - CMP (Chip Multi-processor)
      - SMT (Simultaneous Multithreading)

참고
0. Kernel patch commit message
    - https://github.com/iamroot16/linux/commit/a530b7958612bafe2027e21359083dba84f0b3b4#diff-5050eed868076fe2656aea8c2eb7312a : percpu: teach large page allocator about NUMA
2. 문C블로그
    - http://jake.dothome.co.kr/per-cpu/
    - http://jake.dothome.co.kr/setup_per_cpu_areas/
    - http://jake.dothome.co.kr/per-cpu-dynamic/
    - http://jake.dothome.co.kr/per-cpu-atomic/
5. etc
    - https://kjhg4321.gitbook.io/doodl/per-cpu : 양원혁님 per-cpu 정리
    - https://kernelnewbies.org/FAQ/DoWhile0

## 55주차
> 요약  
> 1. 진행사항
>  - start_kernel (init/main.c)  
>    - setup_arch (arch/arm64/kernel/setup.c)  
>      - cpu_read_bootcpu_ops (arch/arm64/include/asm/cpu_ops.h)  
>        - cpu_read_ops (arch/arm64/kernel/cpu_ops.c)  
>          - cpu_read_enable_method  
>          - cpu_get_ops  
>      - smp_init_cpus (arch/arm64/kernel/smp.c)  
>          - of_parse_and_init_cpus  
>            - is_mpidr_duplicate  
>            - early_map_cpu_to_node (arch/arm64/mm/numa.c)  
>              - set_cpu_numa_node (include/linux/topology.h)  
>                - per_cpu (include/linux/percpu-defs.h)  
>                  - per_cpu_ptr    
>          - smp_cpu_setup (arch/arm64/kernel/smp.c) <-- 대충 이부분까지 참석  
>            - cpu_read_ops (arch/arm64/kernel/cpu_ops.c)  
>            - smp_spin_table_cpu_init (arch/arm64/kernel/smp_spin_table.c)  
>            - set_cpu_possible (include/linux/cpumask.h)  
>      - smp_build_mpidr_hash (arch/arm64/kernel/setup.c)  
>        - MPIDR_AFFINITY_LEVEL (arch/arm64/include/asm/cputype.h)  
>        - fls  
>        - ffs  
>    - add_latent_entropy (include/linux/random.h)  
>    - add_device_randomness (drivers/char/random.c)  
>    - boot_init_stack_canary (arch/arm64/include/asm/stackprotector.h)  
>      - get_random_bytes (drivers/char/random.c)  
>        - _get_random_bytes  
>    - mm_init_cpumask (include/linux/mm_types.h)  
>    - setup_command_line (init/main.c)  
>    - setup_nr_cpu_ids (kernel/smp.c)  
>    - setup_per_cpu_areas (arch/arm64/mm/numa.c)  
>      - pcpu_embed_first_chunk (mm/percpu.c)  
>        - pcpu_build_alloc_info (mm/percpu.c)  


1. 정리
    - Array of zero-length
    ``` bash
    sunghyun@sunghyun:/mnt/d/Dropbox/laptop/iamroot/sources$ cat ./array-of-length-zero.c
    #include <stdio.h>

    struct test{
            int a;
            int b[];
    };

    struct test k = {.b = {[4]=3}};
    struct test p = {.b = {[6]=3}};

    int main()
    {
            printf("%ld\n", sizeof(struct test));
            for(int i=0;i<7;i++){
                    printf("%d %d\n",k.b[i],p.b[i]);
            }
            return 0;
    }
    sunghyun@sunghyun:/mnt/d/Dropbox/laptop/iamroot/sources$ gcc -o array-of-length-zero ./array-of-length-zero.c
    sunghyun@sunghyun:/mnt/d/Dropbox/laptop/iamroot/sources$ ./array-of-length-zero
    4
    0 0
    0 0
    0 0
    0 0
    3 0
    0 0
    0 3
    ```

참고
0. Kernel patch commit message
    - https://patchwork.kernel.org/patch/2657941/ : \[RFC,1/2\] ARM: kernel: build MPIDR hash function data structure
    - https://github.com/torvalds/linux/commit/c1a2f7f0c06454387c2cd7b93ff1491c715a8c69 : mm: Allocate the mm_cpumask (mm->cpu_bitmap[]) dynamically based on n…
1. Kernel Doc
    - /Documentation/arm64/booting.txt
2. 문C블로그
    - http://jake.dothome.co.kr/smp_init_cpus/
    - http://jake.dothome.co.kr/dtb2/
    - http://jake.dothome.co.kr/per-cpu/
    - http://jake.dothome.co.kr/smp_build_mpidr_hash/
    - http://jake.dothome.co.kr/smp_setup_processor_id/
    - http://jake.dothome.co.kr/boot_init_stack_canary/
    - http://jake.dothome.co.kr/setup_per_cpu_areas/
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html : Array of zero-length
5. etc
    - https://app.gitbook.com/@paran-lee/s/qemu/x86_64-aarch64 : x86_64 호스트에서 aarch64 가상화 환경 구축
    - https://elinux.org/images/0/00/Clement-smp-bring-up-on-arm-soc.pdf : 2004-Embedded Linux Conf.-SMP bring up on ARM SoCs
    - https://ko.wikipedia.org/wiki/Big.LITTLE
    - https://en.wikipedia.org/wiki/ARM_big.LITTLE
    - https://namu.wiki/w/ARM%20big.LITTLE%20%EC%86%94%EB%A3%A8%EC%85%98
    - https://lwn.net/Articles/539082/ : Multi-cluster power management
    - https://lwn.net/Articles/481055/ : Linux support for ARM big.LITTLE
    - https://en.wikipedia.org/wiki/Hardware_random_number_generator
    - https://en.wikipedia.org/wiki//dev/random
    - https://en.wikipedia.org/wiki/Random_number_generator_attack
    - https://github.com/ARM-software/TZ-TRNG
    - https://ko.wikipedia.org/wiki/버퍼_오버플로_보호#카나리스
    - 

## 54주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c) 복습  
>    - request_standard_resources (arch/arm64/kernel/setup.c)  
>        - request_resource (kernel/resource.c)  
>          - request_resource_conflict  
>            - __request_resource  
>    - psci_dt_init (drivers/firmware/psci.c)  
>        - of_find_matching_node_and_match (drivers/of/base.c)  
>        - psci_0_2_init (drivers/firmware/psci.c)  
>          - get_set_conduit_method  
>            - set_conduit  
>              - __invoke_psci_fn_hvc  
>                - arm_smccc_hvc  
>              - __invoke_psci_fn_smc  
>                - arm_smccc_smc  
>          - psci_probe  
>            - psci_get_version  
>            - psci_0_2_set_functions  
>            - psci_init_migrate  
>            - psci_init_smccc  
>            - psci_init_cpu_suspend  
>            - psci_init_system_suspend  
>    - cpu_read_bootcpu_ops (arch/arm64/include/asm/cpu_ops.h)  
>      - cpu_read_ops (arch/arm64/kernel/cpu_ops.c)  
>        - cpu_read_enable_method  

1. 정리
    - SMCCC (Secure Monitor Call Calling Convention)
      - /arch/arm64/kernel/smccc-call.S
      ``` asm
            .macro SMCCC instr
            .cfi_startproc
            \instr	#0
            ldr	x4, [sp]
            stp	x0, x1, [x4, #ARM_SMCCC_RES_X0_OFFS]
            stp	x2, x3, [x4, #ARM_SMCCC_RES_X2_OFFS]
            ldr	x4, [sp, #8]
            cbz	x4, 1f /* no quirk structure */
            ldr	x9, [x4, #ARM_SMCCC_QUIRK_ID_OFFS]
            cmp	x9, #ARM_SMCCC_QUIRK_QCOM_A6
            b.ne	1f
            str	x6, [x4, ARM_SMCCC_QUIRK_STATE_OFFS]
        1:	ret
            .cfi_endproc
            .endm
        /*
        * void arm_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2,
        *		  unsigned long a3, unsigned long a4, unsigned long a5,
        *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res,
        *		  struct arm_smccc_quirk *quirk)
        */
        ENTRY(__arm_smccc_smc)
            SMCCC	smc
        ENDPROC(__arm_smccc_smc)
        EXPORT_SYMBOL(__arm_smccc_smc)

        /*
        * void arm_smccc_hvc(unsigned long a0, unsigned long a1, unsigned long a2,
        *		  unsigned long a3, unsigned long a4, unsigned long a5,
        *		  unsigned long a6, unsigned long a7, struct arm_smccc_res *res,
        *		  struct arm_smccc_quirk *quirk)
        */
        ENTRY(__arm_smccc_hvc)
            SMCCC	hvc
        ENDPROC(__arm_smccc_hvc)
        EXPORT_SYMBOL(__arm_smccc_hvc)
      ```

참고
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt
    - https://www.kernel.org/doc/Documentation/locking/spinlocks.txt : rwreader-writer spinlocks
    - https://www.kernel.org/doc/Documentation/devicetree/bindings/arm/psci.txt
    - /Documentation/devicetree/bindings/arm/cpus.yaml ; 소스 내의 파일을 볼 것
2. 문C블로그
    - http://jake.dothome.co.kr/arm_memblock_init/
    - http://jake.dothome.co.kr/request_standard_resources/
    - http://jake.dothome.co.kr/tcm_init/
    - http://jake.dothome.co.kr/psci_init/
    - http://jake.dothome.co.kr/smp_setup_processor_id/
4. ARM Doc
    - DEN0022C_Power_State_Coordination_Interface.pdf
    - Q1-ARM-DEN-0028_SMC_Calling_Convention_v1_2_Non_Conf_EAC.pdf
    - ARMv8-A_Programmers_Guide_for_ARMv8-A.pdf
5. etc
    - https://kjhg4321.gitbook.io/doodl/

## 53주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c) 복습  

1. 정리
    - 동기화
      - 스핀락
      - 뮤텍스
      - 세마포어
      - 커널 단과 어플리케이션 단 차이
    - 커널 분석시
      - 세팅 되는 것들을 파악하면서 진행해야 함
        - ex) bootmem_init 진행되었을 때 --> /proc/zoneinfo
      - 각 부분의 큰 그림 정리해가면서 진행 필요

참고
2. 문C블로그
    - http://jake.dothome.co.kr/barriers/
5. etc
    - https://lwn.net/Articles/793253/#Store%20Tearing

## 52주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c) 복습  

1. 정리
    - 커널 코드가 복잡한 이유
      - DRAM이 느려서 캐시 등 아키텍처 특징을 이용해야 됨
    - 메모리 모델
      - flatmem -> discontig -> sparse
      - vmemmem 도입
        - 효율성
        - 메모리 할당 연속성
    - 메모리 정리
      - 실제 사용하는 물리 메모리 256TB
      - 상위 절반은 리니어 매핑
      - 하위는 다이나믹 매핑
        - 5.4 버전부터는 반대로 바뀌었다고 함
      - 리니어 매핑과 다이나믹 매핑에 실제 메모리에 대한 매핑 방식이 다름
    - ARMv8-A_Programmers_Guide_for_ARMv8-A 문서 봐둘 것

참고
0. Kernel patch commit message
    - https://github.com/iamroot16/linux/commit/ec393a0f014eaf688a3dbe8c8a4cbb52d7f535f9 : mm: return zero_resv_unavail optimization
2. 문C블로그
    - http://jake.dothome.co.kr/sparsemem/

## 51주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - zone_sizes_init (arch/arm64/mm/init.c)  
>        - free_area_init_node (mm/page_alloc.c)  
>          - free_area_init_core  
>            - memmap_init  
>              - memmap_init_zone  
>                - __init_single_page  
>                - set_pageblock_migratetype  
>                  - set_pageblock_flags_group  
>        - check_for_memory  
>      - memblock_dump_all (include/linux/memblock.h)  
>        - __memblock_dump_all (mm/memblock.c)  
>          - memblock_dump

1. 정리
    - bootmem_init 완료

참고
0. Kernel patch commit message
    - https://lore.kernel.org/patchwork/patch/624316/ : \[tip/core/rcu,4/4\] list: Use WRITE_ONCE() when initializing list_head structures
    - https://github.com/iamroot16/linux/commit/e58469bafd0524e848c3733bc3918d854595e20f : mm: page_alloc: use word-based accesses for get/set pageblock bitmaps
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/printk-formats.txt
1. 문C블로그
    - http://jake.dothome.co.kr/mem_map/
    - http://jake.dothome.co.kr/sparsemem/
3. etc
    - http://studyfoss.egloos.com/5512112 : \[Linux\] pageflags로 살펴본 메모리의 일생

## 50주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - zone_sizes_init (arch/arm64/mm/init.c)  
>        - free_area_init_node (mm/page_alloc.c)  
>          - calculate_node_totalpages  
>            - zone_spanned_pages_in_node  
>              - adjust_zone_range_for_zone_movable  
>            - zone_absent_pages_in_node  
>              - __absent_pages_in_range  
>          - free_area_init_core  
>            - pgdat_init_internals  
>            - calc_memmap_size  
>            - init_currently_empty_zone  
>            - memmap_init  
>              - memmap_init_zone  
>                - overlap_memmap_init  

1. 정리
    - struct page
      - 64 Byte
      - cscope 322

참고
0. Kernel patch commit message
    - https://lore.kernel.org/patchwork/patch/633557/ : mm/page_alloc.c: introduce kernelcore=mirror option
    - https://lore.kernel.org/patchwork/patch/342354/ : mm: provide more accurate estimation of pages occupied by memmap
1. 문C블로그
    - http://jake.dothome.co.kr/sparsemem/
    - http://jake.dothome.co.kr/mem_map/
    - http://jake.dothome.co.kr/free_area_init_node/

## 49주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - zone_sizes_init (arch/arm64/mm/init.c)  
>        - free_area_init_nodes (mm/page_alloc.c)  
>          - find_zone_movable_pfns_for_nodes  
>        - mminit_verify_pageflags_layout (mm/mm_init.c)  
>        - setup_nr_node_ids (mm/page_alloc.c)  
>        - zero_resv_unavail   
>          - zero_pfn_range  
>            - pfn_valid (arch/arm64/mm/init.c)  
>        - free_area_init_node  
>          - calculate_node_totalpages  
>            - zone_spanned_pages_in_node  

참고
0. Kernel patch commit message
    - https://github.com/iamroot16/linux/commit/ec393a0f014eaf688a3dbe8c8a4cbb52d7f535f9 : mm: return zero_resv_unavail optimization
1. 문C블로그
    - http://jake.dothome.co.kr/zone-types/
    - http://jake.dothome.co.kr/free_area_init_node/

## 48주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - sparse_init (mm/sparse.c)  
>        - sparse_init_nid  
>          - sparse_init_one_section  
>          - sparse_buffer_fini  
>      - zone_sizes_init (arch/arm64/mm/init.c)  
>        - free_area_init_nodes (mm/page_alloc.c)  
>          - find_min_pfn_with_active_regions  
>          - find_zone_movable_pfns_for_nodes  
>            - early_calculate_totalpages  
>            - find_usable_zone_for_movable  

참고
0. Kernel patch commit message
    - https://github.com/torvalds/linux/commit/342332e6a925e9ed015e5465062c38d2b86ec8f9 : mm/page_alloc.c: introduce kernelcore=mirror option
    - https://github.com/torvalds/linux/commit/a5c6d6509342785bef53bf9508e1842b303f1878 : mm, page_alloc: extend kernelcore and movablecore for percent
1. 문C블로그
    - http://jake.dothome.co.kr/sparsemem/
    - http://jake.dothome.co.kr/bootmem_init-64/
    - http://jake.dothome.co.kr/free_area_init_node/
    - http://jake.dothome.co.kr/build_all_zonelists/
    - http://jake.dothome.co.kr/zone-types/

## 47주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - sparse_init (mm/sparse.c)  
>        - sparse_init_nid  
>          - sparse_mem_map_populate (mm/sparse-vmemmap.c)  
>            - vmemmap_populate (arch/arm64/mm/mmu.c)  
>              - pmd_addr_end (include/asm-generic/pgtable.h)  
>              - vmemmap_pgd_populate (mm/sparse-vmemmap.c)  
>                - vmemmap_alloc_block_zero  
>                  - vmemmap_alloc_block  
>                    - __earlyonly_bootmem_alloc  
>                      - memblock_alloc_try_nid_raw (mm/memblock.c)  
>                        - memblock_alloc_internal  
>                - pgd_populate (arch/arm64/include/asm/pgalloc.h)  

참고
1. 문C블로그
    - http://jake.dothome.co.kr/map64/

## 46주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - memblocks_present (mm/sparse.c)  
>        - memory_present  
>      - sparse_init (mm/sparse.c)  
>        - sparse_init_nid  
>          - sparse_mem_map_populate (mm/sparse-vmemmap.c)  
>            - pfn_to_page (include/asm-generic/memory_model.h)  
>              - __pfn_to_page  
>            - vmemmap_populate (arch/arm64/mm/mmu.c)  

1. 정리
    - struct page 구조체 위치 linux/inlcude/linux/mm_types.h(69)
    - vmemmap 관련 모기향 책 213페이지
    - 메모리 모델 모기향 책 4.2
    - vmemmap 개념
      - memmap 크기 때문에 메모리 관리 및 속도 향상을 위해

참고
1. 문C블로그
    - http://jake.dothome.co.kr/bootmem_init-64/
    - http://jake.dothome.co.kr/sparsemem/
    - http://jake.dothome.co.kr/mem_map/
3. etc
    - https://lwn.net/Articles/368869/ : Memory compaction
    - https://woodz.tistory.com/42 : 위 글 번역
    - https://stackoverflow.com/questions/36296130/why-does-is-err-value-cast-negative-max-errno-to-an-unsigned-long : optimize comparison -a < x < 0

## 44주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - arm64_numa_init (arch/arm64/mm/numa.c)  
>        - numa_init  
>          - numa_alloc_distance  
>        - of_numa_init (drivers/of/of_numa.c)  
>          - of_numa_parse_cpu_nodes  
>            - of_get_next_cpu_node (drivers/of/base.c)  
>          - of_numa_parse_memory_nodes (drivers/of/of_numa.c)  
>            - of_address_to_resource (drivers/of/address.c)  
>              - of_get_address  
>              - __of_address_to_resource  
>                - of_translate_address  
>                  - __of_address_to_resource  

참고
1. Kernel doc
    - /Documentation/devicetree/bindings/numa.txt
2. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html
3. etc
    - https://lwn.net/Articles/250967/ : What every programmer should know about memory, Part 1
    - https://lwn.net/Articles/254445/ : Memory part 4: NUMA support
    - http://forum.falinux.com/zbxe/index.php?document_srl=784583 : 디바이스 트리 작성법 2 편

## 43주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - unflatten_device_tree (drivers/of/fdt.c)  
>      - unittest_unflatten_overlay_base (drivers/of/unittest.c)  
>    - bootmem_init (arch/arm64/mm/init.c)  
>      - early_memtest (mm/memtest.c)  
>        - do_onepass  
>          - memtest  
>            - reserve_bad_mem  
>      - arm64_numa_init (arch/arm64/mm/numa.c)  
>        - of_numa_init (drivers/of/of_numa.c)  
>          - of_numa_parse_cpu_nodes  
>            - of_get_next_cpu_node (drivers/of/base.c)  
>          - of_numa_parse_memory_nodes (drivers/of/of_numa.c)  
>            - of_address_to_resource (drivers/of/address.c)  
>              - of_get_address  

1. 정리
    - 코드 진행시 참고한 파일 : arch/arm64/boot/dts/mediatek/mt6755.dtsi

참고
0. Kernel patch commit message
    - https://github.com/torvalds/linux/commit/4a20799d11f64e6b8725cacc7619b1ae1dbf9acd : mm: move memtest under mm
1. Kernel Doc
    - https://www.kernel.org/doc/Documentation/devicetree/bindings/numa.txt
1. 문C블로그
    - http://jake.dothome.co.kr/bootmem_init-64/
    - http://jake.dothome.co.kr/kobject/
3. etc
    - https://wikidocs.net/3205 : 디바이스 트리 오버레이

## 42주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - unflatten_device_tree (drivers/of/fdt.c)  
>      - __unflatten_device_tree  
>        - unflatten_dt_nodes  
>          - populate_node : 복습  
>            - unflatten_dt_alloc  
>            - populate_properties  
>          - reverse_nodes  
>      - of_alias_scan : 완료  
>        - of_find_node_by_path  
>          - of_find_node_opts_by_path  
>            - __of_find_node_by_full_path  
>              - __of_find_node_by_path  
>                - __of_get_next_child  
>        - of_property_read_string  
>          - of_find_property  
>            - __of_find_property  

1. 정리
    - fdt API :  DTB(Device Tree Blob)를 대상으로 동작
    - of API : unflattened DT를 대상으로 동작

참고
1. 문C블로그
    - http://jake.dothome.co.kr/spinlock/
3. etc
    - http://nimhaplz.egloos.com/5301468 : 스핀락
    - http://nimhaplz.egloos.com/5683475 : preemption
    - https://selfish-developer.com/entry/%EC%8A%A4%ED%95%80%EB%9D%BD-%EB%AE%A4%ED%85%8D%EC%8A%A4-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4 : 스핀락, 뮤텍스, 세마포어
    - https://worthpreading.tistory.com/90 : 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이

## 41주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - paging_init (arch/arm64/mm/mmu.c)  
>      - memblock_free  
>      - memblock_allow_resize  
>    - unflatten_device_tree (drivers/of/fdt.c)  
>      - early_init_dt_alloc_memory_arch  
>        - memblock_alloc (include/linux/memblock.h)  
>          - memblock_alloc_try_nid_raw (mm/memblock.c)  
>            - memblock_alloc_internal  
>              - memblock_alloc_range_nid  
>      - __unflatten_device_tree  
>        - unflatten_dt_nodes  
>          - populate_node  
>            - unflatten_dt_alloc  
>            - populate_properties  

1. 정리
    - unflatten_device_tree 에서 첫 함수인 __unflatten_device_tree 에서는 flatten 데이터를 트리 구조의 구조체에 포인터로 연결을 함

참고
1. 문C블로그
    - http://jake.dothome.co.kr/linux_kernel/linux_4/
    - http://jake.dothome.co.kr/setup_arch-64/
    - http://jake.dothome.co.kr/memblock-2/
    - http://jake.dothome.co.kr/kobject/
    - http://jake.dothome.co.kr/unflatten_device_tree/
    - http://jake.dothome.co.kr/dtb1/
    - http://jake.dothome.co.kr/dtb-fdt-api/
    - http://jake.dothome.co.kr/dtb-of-api/
2. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Alignment.html
3. etc
    - https://github.com/iamroot16a/study/wiki/memblock#__next_mem_range() : iamroot16a 위키
    - https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C : 트리 순회
    - http://soen.kr/lecture/ccpp/cpp1/13-4-1.htm : C language bit field

## 40주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - paging_init (arch/arm64/mm/mmu.c)  
>      - cpu_replace_ttbr1  
>        - cpu_install_idmap  
>          - cpu_set_reserved_ttbr0  
>          - local_flush_tlb_all  
>          - cpu_set_idmap_tcr_t0sz  
>          - cpu_switch_mm  
>        - idmap_cpu_replace_ttbr1  
>        - cpu_uninstall_idmap  
>          - cpu_set_reserved_ttbr0  
>          - local_flush_tlb_all  
>          - cpu_set_idmap_tcr_t0sz  
>          - cpu_switch_mm  

1. 정리
    - ttbr 에 0을 채워주고 난 후에 TLB flush 해야함
    - ttbr1에 swapper_pg 를 넣어주기 위해 idmap_pg 를 이용
    - 그래서 __pa_symbol(idmap_cpu_replace_ttbr1) 즉, 함수의 물리주소 이용
    - ASID (Address Space ID)

참고
0. Kernel patch commit message
    - https://patchwork.kernel.org/patch/9992927/
    - https://github.com/torvalds/linux/commit/50e1881ddde2a986c7d0d2150985239e5e3d7d96#diff-06e4e0038f65519bf8ab7562398c81be
1. 문C블로그
    - http://jake.dothome.co.kr/map64/
    - http://jake.dothome.co.kr/static-keys/
    - http://jake.dothome.co.kr/cpu_replace_ttbr1/
    - http://jake.dothome.co.kr/copy_from_user/
2. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html
3. ARM Doc
    - https://armv8-ref.codingbelief.com/en/chapter_d4/d42_2_controlling_address_translation_stages.html
3. etc
    - http://recipes.egloos.com/5232056 : 임베디드레시피 MMU 설명
    - https://woodz.tistory.com/67 : Likely 및 Unlikely 매크로 예제 설명

## 39주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - paging_init (arch/arm64/mm/mmu.c)  
>      - map_kernel  
>        - map_kernel_segment  
>      - map_mem  

1. 정리
    - swapper_pg_dir 세팅 하는 과정
    - 이 과정 후에 init_pg_dir를 바꾸는 과정을 진행할 것으로 보임
    - 타입 변환 및 구조체 참조 코드
      ```C
        #include <stdio.h>
        #include <stdio.h>

        typedef unsigned long u64;
        typedef u64 pteval_t;
        typedef struct { pteval_t pte; } pte_t;
        #define pte_val(x)      ((x).pte)
        #define __pte(x)        ((pte_t) { (x) } )

        typedef u64 pgdval_t;
        typedef struct { pgdval_t pgd; } pgd_t;
        #define pgd_val(x)      ((x).pgd)
        #define __pgd(x)        ((pgd_t) { (x) } )

        static inline pte_t pgd_pte(pgd_t pgd)
        {
                return __pte(pgd_val(pgd));
        }

        int main()
        {
                pgd_t pg;
                pg.pgd = 500;

                printf("%lu \n", pg.pgd);
                printf("%lu \n", pgd_pte(pg));
                printf("%lu \n", pte_val(pgd_pte(pg)));

                return 0;
        }
      ```
      ```bash
        sunghyun@sunghyun:~$ vim ./pte-test.c
        sunghyun@sunghyun:~$ gcc -o pte-test ./pte-test.c
        ./pte-test.c: In function ‘main’:
        ./pte-test.c:25:19: warning: format ‘%lu’ expects argument of type ‘long unsigned int’, but argument 2 has type ‘pte_t {aka struct <anonymous>}’ [-Wformat=]
                printf("%lu \n", pgd_pte(pg));
                        ~~^      ~~~~~~~~~~~
        sunghyun@sunghyun:~$ ./pte-test
        500
        500
        500
      ```
    - 2
    ```C
        #include <stdio.h>
        #include <stdint.h>
        struct pgd_t{
            uint64_t val;
        };
        static inline uint64_t pgd_val(struct pgd_t pgd){
            return pgd.val;
        }
        uint64_t table[512] = {255,254,253};
        int main(){
            struct pgd_t *pgdp = table;
            struct pgd_t pgd = *pgdp;
            printf("%p\n", pgdp);
            printf("%ld\n", pgd);
            printf("%ld\n", pgd_val(pgd));
            printf("%ld\n", pgd_val(*(pgdp+0)));
            printf("%ld\n", pgd_val(*(pgdp+1)));
            printf("%ld\n", pgd_val(*(pgdp+2)));
        }
    ```
    ```bash
        0x601060
        255
        255
        255
        254
        253
    ```

참고
1. 문C블로그
    - http://jake.dothome.co.kr/map64/
    - http://jake.dothome.co.kr/pt64/
2. iamroot 질답
    - http://www.iamroot.org/xe/index.php?document_srl=210100&mid=Programming

## 38주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - arm64_memblock_init (/arch/arm64/mm/init.c)  
>    - paging_init (arch/arm64/mm/mmu.c)  
>      - map_kernel  
>        - map_kernel_segment  

참고
1. 문C블로그
    - http://jake.dothome.co.kr/cma/
    - http://jake.dothome.co.kr/dma_contiguous_remap/
    - 
2. Kernel Doc  
    - https://www.kernel.org/doc/gorman/html/understand/understand009.html
    - 
3. GCC Doc
    - https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html
    - 

## 37주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - arm64_memblock_init (/arch/arm64/mm/init.c)  
>      - reserve_crashkernel  
>      - reserve_elfcorehdr  
>      - dma_contiguous_reserve  
>        - ...
>          - cma_init_reserved_mem 진행 중  

참고
1. 문C블로그
    - http://jake.dothome.co.kr/arm64_memblock_init/
    - http://jake.dothome.co.kr/reserve_crashkernel/
2. Kernel Doc  
    - https://www.kernel.org/doc/Documentation/kdump/kdump.txt

## 36주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - arm64_memblock_init (/arch/arm64/mm/init.c)  
>      - early_init_fdt_scan_reserved_mem (drivers/of/fdt.c))  

## 35주차
> 요약  
> 1. 진행사항
>  - setup_arch (arch/arm64/kernel/setup.c)  
>    - arm64_memblock_init (/arch/arm64/mm/init.c)  
>      - fdt_enforce_memory_region (/arch/arm64/mm/init.c)  
>        - early_init_dt_scan_usablemem (/arch/arm64/mm/init.c)  
>        - memblock_cap_memory_range (/mm/memblock.c)  
>      - early_init_fdt_scan_reserved_mem (drivers/of/fdt.c)  
>          - fdt_get_mem_rsv  
>          - __fdt_scan_reserved_mem  
>          - fdt_init_reserved_mem  

참고
1. 문C블로그
    - http://jake.dothome.co.kr/arm64_memblock_init/
2. Kernel Doc  
    - https://www.kernel.org/doc/Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt

## 34주차
> 요약  
> 1. 진행사항  
> start_kernel (init/main.c)  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - cpu_uninstall_idmap (arch/arm64/include/asm/mmu_context.h) 진행 중  
>      - cpu_set_reserved_ttbr0 (arch/arm64/include/asm/mmu_context.h)  
>      - local_flush_tlb_all (arch/arm64/include/asm/tlbflush.h)  
>      - cpu_set_default_tcr_t0sz (arch/arm64/include/asm/mmu_context.h)  
>      - cpu_switch_mm (arch/arm64/include/asm/mmu_context.h)  
>        - cpu_set_reserved_ttbr0 (arch/arm64/include/asm/mmu_context.h)  
>        - cpu_do_switch_mm (arch/arm64/include/mm/proc.S)  
>    - xen_early_init (include/xen/arm/hypervisor.h)  
>    - efi_init (drivers/firmware/efi/arm-init.c)  
>      - efi_get_fdt_params (drivers/firmware/efi/efi.c)  
>        - fdt_find_uefi_params (drivers/firmware/efi/efi.c)  
>      -  efi_memmap_init_early(drivers/firmware/efi/memmap.c) 완료  
>        - __efi_memmap_init (drivers/firmware/efi/memmap.c)  
>          - early_memremap (mm/early_ioremap.c)  
>            - __early_ioremap (mm/early_ioremap.c)  

1. 정리
    - offsetof 함수
        ```bash
        sunghyun@sunghyun:~$ cat ./offset.c
        #include <stdio.h>

        #define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE *)0)->MEMBER)

        #pragma pack(push,1)
        typedef struct _abc abc;
        struct _abc {
                char a;
                int b;
                int c;
        };
        #pragma pack(pop)


        int main(int argc, char *argv[])
        {
                printf("%lX\n", offsetof(abc, a));
                printf("%lX\n", offsetof(abc, b));
                printf("%lX\n", offsetof(abc, c));

                return 0;
        }
        sunghyun@sunghyun:~$ gcc -o offset ./offset.c
        sunghyun@sunghyun:~$ ./offset
        0
        1
        5
        ```

참고
0. Kernel patch commit message
    - https://www.kernel.org/doc/Documentation/efi-stub.txt
1. 문C블로그
    - http://jake.dothome.co.kr/head-64/
    - http://jake.dothome.co.kr/cpu_replace_ttbr1/
2. ARM® Doc  
    - https://developer.arm.com/docs/ddi0595/b/aarch64-system-registers/tcr_el1
3. etc  
    - https://elixir.bootlin.com/linux/v5.1/ident/idmap_t0sz
    - 

## 33주차
> 요약  
> 1. 진행사항  
> start_kernel (init/main.c)  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - local_daif_restore (arch/arm64/include/asm/daifflags.h) 완료  
>      -  진행 중  

참고
0. Kernel patch commit message
    - https://github.com/iamroot16/linux/commit/cdbc81ddef43c8fdcbd3a26e1a7530c70b629cfc#diff-66b5bf2ac9742f20c65e0b78e669dd77
    - https://patchwork.kernel.org/patch/2849665/
1. 문C블로그
    - http://jake.dothome.co.kr/
    - http://jake.dothome.co.kr/ic/
2. ARM® Doc
    - https://static.docs.arm.com/ihi0069/c/IHI0069C_gic_architecture_specification.pdf
    - https://static.docs.arm.com/ddi0487/ea/DDI0487E_a_armv8_arm.pdf


## 32주차
> 요약  
> 1. 진행사항  
> start_kernel (init/main.c)  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - parse_early_param (init/main.c) 완료  
>      - parse_early_options (init/main.c)   
>        - do_early_param (init/main.c)   
>        - parse_args (kernel/params.c)   
>          - parse_args (kernel/params.c)   

1. 정리
    - f
2. 의문점들
    - d

참고
1. 문C블로그
    - http://jake.dothome.co.kr/parse_args/
    - http://jake.dothome.co.kr/earlycon/

## 31주차
> 요약  
> 1. 진행사항  
> start_kernel (init/main.c)  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - setup_machine_fdt (arch/arm64/mm/mmu.c) 완료  
>      - early_init_dt_scan (drivers/of/fdt.c)     
>        - early_init_dt_scan_memory (drivers/of/fdt.c)   
>          - early_init_dt_add_memory_arch (drivers/of/fdt.c)   
>            - memblock_add (mm/memblock.c)   
>              - memblock_add_range (mm/memblock.c)   
>                - memblock_double_array (mm/memblock.c)   
>                  - memblock_find_in_range (mm/memblock.c)   
>                    - memblock_find_in_range_node (mm/memblock.c)   
>                      - __memblock_find_range_bottom_up (mm/memblock.c)   
>                        - __next_mem_range (mm/memblock.c)   
>                      - __memblock_find_range_top_down (mm/memblock.c)   
>                  - memblock_free (mm/memblock.c)   
>                    - memblock_remove_range (mm/memblock.c)   
>                      - memblock_isolate_range (mm/memblock.c)   
>                        - memblock_insert_region (mm/memblock.c)   
>                      - memblock_remove_region (mm/memblock.c)   
>                - memblock_merge_regions (mm/memblock.c)   
>          - early_init_dt_mark_hotplug_memory_arch (drivers/of/fdt.c)   
>            - memblock_mark_hotplug (drivers/of/fdt.c)   
>              - memblock_setclr_flag (mm/memblock.c)   

참고
1. 문C블로그
    - http://jake.dothome.co.kr/memblock-1/
    - http://jake.dothome.co.kr/memblock-2/
2. partial address space mirroring
    - https://lwn.net/Articles/684866/

## 30주차
> 요약  
> 1. 진행사항  
> start_kernel (init/main.c)  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - setup_machine_fdt (arch/arm64/mm/mmu.c) 진행 중  
>      - early_init_dt_scan (drivers/of/fdt.c)   
>        - early_init_dt_scan_nodes (drivers/of/fdt.c)   
>        - early_init_dt_scan_chosen (drivers/of/fdt.c)   
>        - early_init_dt_scan_root (drivers/of/fdt.c)   
>        - early_init_dt_scan_memory (drivers/of/fdt.c)   
>          - early_init_dt_add_memory_arch (drivers/of/fdt.c)   
>            - memblock_add (mm/memblock.c) 진행 중  

1. 정리
    - fdt 관련 api 정리 필요
    - Device tree
      - The device tree framework source code is located in drivers/of/
      - Code for manipulating the flattened device tree (FDT) is is scripts/dtc/libfdt
2. 의문점들
    - dts,dtsi가 바이너리로 세팅되는 방법

참고
1. 문C블로그
    - http://jake.dothome.co.kr/dtb1/
    - http://jake.dothome.co.kr/dtb2/
    - http://jake.dothome.co.kr/dtb-fdt-api/
2. etc
    - https://elinux.org/Device_Tree_Linux

## 29주차
> 요약  
> 1. 복습  
>    1. 차상우님 물리주소<->가상주소 변환 및 페이지 테이블 세팅  
>    2. 양원혁님 : \[[link](https://ywhyuk.github.io/demo/2020/01/01/Translation-table-format-descriptors.html)\]  
>    - 현재까지 한거 거의 전부 요약된 느낌 !  
> 2. 분석  
> start_kernel (init/main.c)  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - setup_machine_fdt (arch/arm64/mm/mmu.c) 진행 중  
>      - fixmap_remap_fdt (arch/arm64/mm/mmu.c)     
>        - memblock_reserve (mm/memblock.c)   
>          - memblock_add_range (mm/memblock.c)   
>      - early_init_dt_scan (drivers/of/fdt.c)   
>          - early_init_dt_scan_nodes (drivers/of/fdt.c)   
>              - of_scan_flat_dt (drivers/of/fdt.c)   
>              - early_init_dt_scan_chosen (drivers/of/fdt.c)   
>                  - early_init_dt_check_for_initrd (drivers/of/fdt.c)   
>                      - (생략)...  
>                          - fdt_next_tag (scripts/dtc/libfdt/fdt.c) 진행 중  

1. 정리  
    - DTB 구조  
        - 문C블로그 문영일님께서 작성하신 dtb 그림 \[[link](http://jake.dothome.co.kr/dtb1/)\]  
        - [![fig-iamroot-kernel-moonc-dtb1-fig-001](http://jake.dothome.co.kr/wp-content/uploads/2015/11/dtb1.png)](http://jake.dothome.co.kr/dtb1/)  
    - OF (Open Firmware)  
    - bootargs 설정하는 곳 : 검토 필요  
        - bootloader / compile 시점 / device tree  
    - dts, dtsi 차이  
        - .dts <- files for board-level definitions  
        - .dtsi <- files for included files, generally containing SoC-level definitions (the i in dtsi stands for Include)  
    - device tree 의 structure block
        - 4바이트 읽어서 1,2,3 인지에 따라 BEGIN_NODE, END_NODE, PROP 결정  
    - zero length array in structure : a gcc extension  
      ```bash
      sunghyun@sunghyun:/mnt/c/Users/jin/Desktop$ cat ./arr0.c
      #include \<stdio.h\>
      typedef struct arr0 {
              char a;
              char b;
              char c[0];
      } arr0;
      int main(int argc, char *argv[])
      {
              char a[6] = { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC };
              arr0 *aa = (arr0 *) a;
              printf("%p\n", &(aa->a));
              printf("%p\n", &(aa->b));
              printf("%p\n", &(aa->c));
              printf("%p\n", (aa->c+1));
              printf("aa->a    : %x\n", aa->a);
              printf("aa->b    : %x\n", aa->b);
              printf("aa->c[0] : %x\n", (unsigned char)*(aa->c+0));
              printf("aa->c[1] : %x\n", (unsigned char)*(aa->c+1));
              printf("aa->c[2] : %x\n", (unsigned char)*(aa->c+2));
              printf("aa->c[3] : %x\n", (unsigned char)*(aa->c+3));
              return 0;
      }
      sunghyun@sunghyun:/mnt/c/Users/jin/Desktop$ ./arr0
      0x7fffca8bb862
      0x7fffca8bb863
      0x7fffca8bb864
      0x7fffca8bb865
      aa->a    : 12
      aa->b    : 34
      aa->c[0] : 56
      aa->c[1] : 78
      aa->c[2] : 9a
      aa->c[3] : bc
      ```

2. 의문점들
    - Q. Device tree 초기 세팅할 때, CRC32를 이용해 checksum을 계산해놓는데 왜 다른 해쉬함수를 사용하지 않는지 궁금함  
        - 아마도 처음 커널 나올 땐 해쉬함수가 없었을듯 ? 근데 중간에 바뀌지도 않음 ?  
        - 빨라서 ?  
    - Q. 대략 2M dt 에 대한 checksum 계산시 CRC32와 SHA 속도 차이?  

참고
1. 문C블로그
    - http://jake.dothome.co.kr/fixmap/
    - http://jake.dothome.co.kr/memblock-1/
    - http://jake.dothome.co.kr/dtb1/
2. iamroot16a memblock 정리
    - https://github.com/iamroot16a/study/wiki/memblock
3. Device tree - chosen node
    - https://elinux.org/Device_Tree_Usage#chosen_Node
4. array of length zero
    - https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html

## 27주차
> 요약  
> start_kernel (init/main.c) - boot_cpu_init (init/main.c) 내부  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - early_fixmap_init (arch/arm64/mm/mmu.c)   
>    - early_ioremap_init (arch/arm64/mm/ioremap.c)   
>    - setup_machine_fdt (arch/arm64/mm/mmu.c) 진행 중  
>      - fixmap_remap_fdt (arch/arm64/mm/mmu.c)   
>        - __fixmap_remap_fdt (arch/arm64/mm/mmu.c)   
>          - create_mapping_noalloc (arch/arm64/mm/mmu.c)   
>            - __create_pgd_mapping (arch/arm64/mm/mmu.c)   
>              - alloc_init_pud (arch/arm64/mm/mmu.c) 진행 중  

1. Folded 개념  
    - 리눅스에서는 4단계 페이지 테이블을 사용  
    - X86 에서 128 PB 메모리 지원을 위해 5레벨 페이지 테이블이 도입됨  
    - 아키텍처에 따라 HW table 레벨 지원이 달라지기 때문에 folded 개념이 생김  
    - LPAE (Large Physical Address Extension)  

2. 의문점들
    - Q. Folded paging 방식이 실제 하드웨어적으로 동작하는 방법  
    - Q. Fixed_addresses enum 에서 __end_of_permanent_fixed_addresses 와 __end_of_fixed_addresses 구분된 이유?  

참고
1. Folded 개념 참고
    -	http://www.renyujie.net/articles/article_os_kernel_1.php
2. 5-level paging at lwn.net
	  - https://lwn.net/Articles/708526/
3. 문C블로그
    - http://jake.dothome.co.kr/pt/
    - http://jake.dothome.co.kr/pt64/
    - http://jake.dothome.co.kr/fixmap/

## 26주차
> 요약  
> start_kernel (init/main.c) - boot_cpu_init (init/main.c) 내부  
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - early_fixmap_init (arch/arm64/mm/mmu.c) 진행 중  

1. early_fixmap_init (arch/arm64/mm/mmu.c)  
    - init_pg_dir, swapper_pg_dir 차이  
    - __VA_ARGS__ 동작 예제 코드
      ```bash
      sunghyun@sunghyun:/mnt/c/Users/jin/Desktop$ cat ./test.c
      #include <stdio.h>
      #define a1(x) printf("%d...a1\n", x);
      #define a2(x) printf("%d...a2\n", x);
      #define a(x,y,z,...) a##z(x)
      #define aa(x,...) a(x, ##__VA_ARGS__, 1, 2)
      int main()
      {
              aa(5);
              aa(6, 1);
              return 0;
      }
      sunghyun@sunghyun:/mnt/c/Users/jin/Desktop$ ./test
      5...a2
      6...a1
      ```

참고
1. arm64/mm: Separate boot-time page tables from swapper_pg_dir
    - https://github.com/raspberrypi/linux/commit/2b5548b68199c17c1466d5798cf2c9cd806bdaa9
2. 문C블로그
    - http://jake.dothome.co.kr/pt64/
    - http://jake.dothome.co.kr/map64/
    - http://jake.dothome.co.kr/fixmap/
2. iamroot
    - http://www.iamroot.org/xe/index.php?document_srl=209118&mid=Programming#1
3. page table management
    - https://www.kernel.org/doc/gorman/html/understand/understand006.html
4. linux mmu and page table mapping
    - https://developpaper.com/original-armv8-mmu-and-linux-page-table-mapping/

## 25주차
> 요약  
> start_kernel (init/main.c) - boot_cpu_init (init/main.c) 내부  
>  - page_address_init (mm/highmem.c)   
>  - setup_arch (arch/arm64/kernel/setup.c) 진행 중  
>    - early_fixmap_init (arch/arm64/mm/mmu.c) 진행 중  

## 24주차
> 요약  
> start_kernel (init/main.c) - boot_cpu_init (init/main.c) 내부  
>  - smp_processor_id (kernel/cpu.c) 완료  
>  - set_cpu_(online, active, present, possible) (include/linux/cpumask.h) 완료  

start_kernel() -  init/main.c  
  boot_cpu_init() -  init/main.c  
    smp_processor_id() -  kernel/cpu.c  
      raw_smp_processor_id() include/linux/smp.h   //   (*raw_cpu_ptr(&cpu_number))  
    set_cpu_{ online | active | present | possible }(cpu, {true | false}) // cpu bitmap setting (set or clear)  
  
1. smp_processor_id  
```c  
arch/arm64/include/asm/smp.h  
DECLARE_PER_CPU_READ_MOSTLY(int, cpu_number);  
arch/arm64/kernel/smp.c  
DEFINE_PER_CPU_READ_MOSTLY(int, cpu_number);  
EXPORT_PER_CPU_SYMBOL(cpu_number);  
  
#define DEFINE_PER_CPU_SECTION(type, name, sec) \_\_PCPU_ATTRS(sec) \_\_typeof\_\_(type) name  
#define \_\_PCPU_ATTRS(sec) \_\_percpu \_\_attribute\_\_((section(PER_CPU_BASE_SECTION sec))) PER_CPU_ATTRIBUTES  
  
#define raw_cpu_ptr(ptr) ({ \  
  __verify_pcpu_ptr(ptr); \ // ptr 변수가 들어온지 컴파일 타임에 확인하기 위한 함수 ?  
  arch_raw_cpu_ptr(ptr); \  
})  
  
#define arch_raw_cpu_ptr(ptr) SHIFT_PERCPU_PTR(ptr, __my_cpu_offset)  
  
static inline unsigned long __my_cpu_offset(void)  
{  
   unsigned long off;  
   /*  
    * We want to allow caching the value, so avoid using volatile and  
    * instead use a fake stack read to hazard against barrier().  
    */  
   asm(ALTERNATIVE("mrs %0, tpidr_el1",  
                   "mrs %0, tpidr_el2",  
                   ARM64_HAS_VIRT_HOST_EXTN)  
       : "=r" (off) :  
       "Q" (*(const unsigned long *)current_stack_pointer));  
  
   return off;  
}  
```

volatile 이 없음  
입력 변수가 사용되지 않지만 존재  
AAPCS64 에서 stack 는 full-descending 방식으로 변화됨  
즉, sp 는 off 가 들어있는 곳을 가리킴  
비어있는 레지스터에 값을 읽어오고 추후에 off에 값을 넣는방식으로 동작  
  
2. set_cpu_\{online, active, present, possible \}  
p[nr / \_\_BITS_PER_LONG]  |= 1UL << (nr % \_\_BITS_PER_LONG); // atomic하지 않은 동일한 코드  
  
\_\_builtin_return_address(0) : This function returns the return address of the current function, or of one of its callers. The level argument is number of frames to scan up the call stack. A value of 0 yields the return address of the current function, a value of 1 yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the noinline function attribute.  
  
참고  
1. http://jake.dothome.co.kr/attr1/  
2. http://jake.dothome.co.kr/per-cpu/  
3. http://recipes.egloos.com/5059742  
4. https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/using-the-stack-in-aarch32-and-aarch64  
5. https://lore.kernel.org/linux-arm-kernel/20180904104830.2975-5-mark.rutland@arm.com/  
6. https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html  

## 20주차 == 23주차
> 요약  
> start_kernel (init/main.c) - setup_arch (arch/arm64/kernel/setup.c) 내부  
>  - early_fixmap_init (arch/arm64/mm/mmu.c)   
>  - early_ioremap_init (arch/arm64/mm/ioremap.c)   
>  - setup_machine_fdt (arch/arm64/kernel/setup.c) 진행 중  

## 19주차
> 요약  
> 통합 시도 스터디 2차 진행  
> A조 스타일  

## 18주차
> 요약  
> 통합 시도 스터디 진행
> 라인바이라인 분석    
> 1. start_kernel 함수 분석  
> 통합할 경우 어떤 방식으로 진행할지 논의  
> ~~논의가 필요한 사항이긴 하지만 어쨌건 평소 스터디보다 만족스럽지 못한 시간 ...~~  

## 17주차
> 요약  
> 13 - 20 스터디 진행  
> 1. Control groups 관련 문서
> - \[LinuxCon Europe 2016\] Control Groups (cgroups) \[[link](http://man7.org/conf/lceu2016/cgroups-LinuxCon.eu_2016-Kerrisk.pdf)\]  
>   
> 20 - 21 강남 이동  
> 21 - 22 조전체 통합 논의  

## 16주차
> 요약  
> 1. arch/arm64/kernel/head.S 재분석 완료  
> - KASLR 생략  
>
> 2. init/main.c : start_kernel 분석  
> - cgroups(Control Groups) 내용 확인  
> - cgroup 관련 자료구조 분석  
> - cgroup_init_early 진행  

## 15주차
> 요약  
> arch/arm64/kernel/head.S  
> - __create_page_tables 완료  
> - idmap_pg_dir 구조 예제 정리 그림  
> ![fig-iamroot-kernel-001-idmap_pg_dir](/assets/img/iamroot16-kernel/191012-iamroot-kernel-001-idmap_pg_dir.png)  

## 14주차
> 요약  
> 부트로더 종류 및 역할  
> Divice Tree 역할 및 예제 확인  
> arch/arm64/kernel/head.S  
> - __create_page_tables 에서 VA_BITS가 PA_BITS보다 작을 경우

## 13주차
> 요약  
> init/main.c : start_kernel 분석  
> - fixmap  
>
> arch/arm64/kernel/head.S : 위 내용과 연관된 부분 복습  
> - 커널 이미지 구성  
> - __create_page_tables  

## 11주차
> 요약  
> init/main.c : start_kernel 분석  
> - cgroups(Control Groups)  
> - Static Key  

## 10주차
> 요약  
> init/main.c : start_kernel 분석  
> - cgroups(Control Groups)  

## 9주차
> 요약  
> arch/arm64/kernel/head.S 분석 완료  
> init/main.c : start_kernel 분석 시작  

## 8주차
> 요약  
> arch/arm64/kernel/head.S 분석  

## 7주차
> 요약  
> arch/arm64/kernel/head.S 분석  

## 6주차
> 요약  
> arch/arm64/kernel/head.S 분석  

## 5주차
> 요약  
CISC-S 2019 발표로 인한 불참  
> "코드로 알아보는 ARM 리눅스 커널"  
> - 1장 ARMv8 아키텍처  

> arch/arm64/kernel/head.S 분석 시작  

## 4주차
> 요약  
> "리눅스 커널 내부구조"  
> - 6장 인터럽트와 트랩 그리고 시스템 호출  

## 3주차
> 요약  
> "리눅스 커널 내부구조"  
> - 4장 메모리관리  
> - 5장 파일시스템과 가상 파일시스템  

## 2주차
> 요약  
> "리눅스 커널 내부구조"  
> - 3장 태스크 관리  
> - 4장 메모리관리 (~Buddy와 Slab)  

## 1주차
> 요약  
> "코드로 알아보는 ARM 리눅스 커널"  
> - 1장 ARMv8 아키텍처  

1. 의문점들
   - 용어
      - 마이크로 아키텍처, TrustZone, Trusted Execution Environment
   - ARMv7 AArch32 vs ARMv8 AArch32 차이
   - ILP32, LP64, 리눅스 데이터 모델
   - 함수 호출시 파라미터 몇개인지 체크하는 방법
   - AAPCS64가 caller, callee에서 레지스터 나눠서 처리하게 하는 방식 사용하는 이유
   - IRQ, FIQ 방식 차이
